	<!DOCTYPE html>
	<html>
		<head>
			<title>QA Department</title>
			<meta charset="UTF-8">
			<link rel="stylesheet" href="style.css">
		</head> 

		<body>
				
		    <nav>
				<ul>
			  	    <li><a href="index.html">Начало</a> </li> 
			  		<li><a href="portfolio.html">Тестване</a> </li>
			  		<li><a href="about.html">Отдел</a> </li>
			  		<li><a href="contact.html">Контакти</a> </li>
			  		<li><a href="automation.html">Автоматизация</a> </li>
			  		<li><a href="exercise.html">Упражнения</a> </li>
			  		<div class="logo"><a href="#"><img src ="img/ctGaming.png"</a> 
			  	</ul>
			</nav>

			<div class= testing-types>
		    	<p><a>Видове тестване:</a><br></p>

		    		<a>1. Alpha Testing:</a><br>
		    			<a>Това е най-често използваното тестване в софтуерната индустрия. Целта на това тестване е да се
		    		    идентифицират всички възможни проблеми или дефекти, преди да се пусне на пазара или на потребителя.
		    			Алфа тестването ще се проведе в края на фазата на разработка на софтуер, но преди бета тестването.<br>
		    			Tози вид тестване ще се извършва на сайта на разработчика. За този тип тестване може да се създаде
		    		    вътрешна виртуална потребителска среда.</a>
		    			<p></p>
		    			<br></br>
		    		<a>2. Acceptance Testing:</a><br>
		    			<a>Тест за приемане се извършва от клиента и той проверява дали потокът от край до край на системата<br> отговаря на бизнес изискванията или не и дали отговаря на нуждите на крайния потребител.<br>
						Клиентът приема софтуера само когато всички функции и функционалности работят според очакванията. Това е последната фаза на тестване, след което софтуерът влиза в производство. Това се нарича още тест за приемане на потребителя (UAT- User Acceptance Testing).</a>
						<p></p>
		    			<br></br>
		    		<a>3. Monkey Testing:</a><br>
		    			<a>Самото име подсказва, че това тестване се извършва на ad-hoc основа, т.е. без позоваване на тестовия случай, а също и без никакъв план или документация за този тип тестване.
						Целта на това тестване е да се намерят дефектите и да се разбие приложението чрез изпълнение на всеки поток от приложението или произволна функционалност.
						Ad-hoc тестването е неформален начин за откриване на дефекти и може да се извърши от всеки в проекта.<br>Трудно е да се идентифицират дефекти без тестов случай, но понякога е възможно дефектите, открити по време на ad-hoc тестване, да не са били идентифицирани с помощта на съществуващите тестови случаи.<br>
						Какво всъщност е "Ad hoc"? Ad hoc е латински фраза, която означава буквално „към това“. На английски език обикновено означава решение за конкретна цел, проблем или задача, а не обобщено решение, адаптивно към странични случаи.</a>
						<p></p>
		    			<br></br>
		    		<a>4. Accessibility Testing:</a><br>
		    			<a>Целта на тестването за достъпност е да се определи дали софтуерът или приложението са достъпни за хора с увреждания или не.
						Тук инвалидност означава глухота, цветна слепота, умствени увреждания, напреднала възраст и други групи с увреждания. Извършват се различни проверки като размер на шрифта за хора с увреждания, цвят и контраст за цветна слепота и др.</a>	
						<p></p>
		    			<br></br>
		    		<a>5. Beta Testing:</a><br>
		    			<a>Бета тестването е официален тип софтуерно тестване, което се извършва от клиента. Извършва се в реалната среда преди пускането на продукта на пазара за действителните крайни потребители.
						Бета тестването се извършва, за да се гарантира, че няма големи повреди в софтуера или продукта и отговаря на бизнес изискванията от гледна точка на крайния потребител. Бета тестването е успешно, когато клиентът приеме 	софтуера.
						Обикновено това тестване се извършва от крайните потребители или други. Това е последното тестване, направено преди пускането на приложението за търговски цели. Обикновено бета версията на пуснатия софтуер или продукт е ограничена до определен брой потребители в определена област.
						Така че крайният потребител всъщност използва софтуера и споделя обратната връзка с компанията. След това компанията предприема необходимите действия, преди да пусне софтуера в световен мащаб.</a>	
						<p></p>
		    			<br></br>
		    		<a>6. Back-end Testing:</a><br>
		    			<a>Всеки път, когато вход или данни се въвеждат във входното приложение, те се съхраняват в базата данни и тестването на такава база данни е известно като тестване на база данни или бекенд тестване.
						Има различни бази данни като SQL Server, MySQL и Oracle и т.н. Тестването на база данни включва тестване на структурата на таблицата, схемата, съхранената процедура, структурата на данните и т.н.
						При бек-енд тестване GUI не участва, тестерите са директно свързани към базата данни с правилен достъп и могат лесно да проверят данните, като изпълнят няколко заявки в базата данни.
						Може да има идентифицирани проблеми като загуба на данни, блокиране, повреда на данните и т.н. по време на това бекенд тестване и тези проблеми са от решаващо значение за отстраняване, преди системата да влезе в експлоатация в производствената среда</a>
						<p></p>
		    			<br></br>
		    		<a>7. Back-end Testing:</a><br>	
		    			<a>Това е подтип тестване за съвместимост (което е обяснено по-долу) и се извършва от екипа за тестване.
						Тестването за съвместимост на браузъра се извършва за уеб приложения и гарантира, че софтуерът може да работи с комбинация от различни браузъри и операционни системи. Този тип тестване също така потвърждава дали дадено уеб приложение работи на всички версии на всички браузъри или не.</a>
						<p></p>
		    			<br></br>
		    	    <a>8. Browser Compatibility Testing:</a><br>	
		    			<a>Това е подтип тестване за съвместимост и се извършва от екипа за тестване.
						Тестването за съвместимост на браузъра се извършва за уеб приложения и гарантира, че софтуерът може да работи с комбинация от различни браузъри и операционни системи. Този тип тестване също така потвърждава дали дадено уеб приложение работи на всички версии на всички браузъри или не.</a>
						<p></p>
		    			<br></br>
		    		<a>9. Black Box Testing:</a><br>	
		    			<a>Тестването с "черна кутия" е метод за тестване на софтуер, който изследва функционалността на дадено приложение, без да се вглежда в неговите вътрешни структури. Този метод на тест може да се приложи практически към всяко ниво на софтуерно тестване: единица, интеграция, система и приемане. Вътрешният дизайн на системата не се разглежда при този тип тестване. Тестовете се базират на изискванията и функционалността.</a>
						<p></p>
		    			<br></br>
		    		<a>10. Boundary Value Testing:</a><br>	
		    			<a>Този тип тестване проверява поведението на приложението на гранично ниво.
						Извършва се тест на гранични стойности, за да се провери дали има дефекти при гранични стойности. Тестването на гранични стойности се използва за тестване на различен диапазон от числа. Има горна и долна граница за всеки диапазон и се извършва тестване на тези гранични стойности.Ако тестването изисква тестов диапазон от числа от 1 до 500, тогава тестването на гранична стойност се извършва на стойности при 0, 1, 2, 499, 500 и 501..</a>
						<p></p>
		    			<br></br>	
		    		<a>11. Branch Testing:</a><br>	
		    			<a>Това е вид тестване на "white box" и се извършва по време на Unit Testing. Branch Testing, самото име, предполага, че кодът се тества задълбочено чрез преминаване във всеки клон. Тестването на клонове се дефинира като метод за тестване, чиято основна цел е да гарантира, че всеки един от възможните разклонения от всяка точка на решение се изпълнява поне веднъж и по този начин гарантира, че целият достъпен код се изпълнява</a>
						<p></p>
		    			<br></br>	
		    		<a>12. Comparison Testing:</a><br>	
		    			<a>Сравнението на силните и слабите страни на даден продукт с предишните му версии или други подобни продукти се нарича сравнително тестване.</a>
						<p></p>
		    			<br></br>	
		    		<a>13. Compatibility Testing:</a><br>	
		    			<a>Това е тип тестване, при което се потвърждава как се държи и работи софтуерът в различна среда, уеб сървъри, хардуер и мрежова среда. Тестването за съвместимост гарантира, че софтуерът може да работи в различна конфигурация, различни бази данни, различни браузъри и техните версии. Тестването за съвместимост се извършва от екипа за тестване.</a>
						<p></p>
		    			<br></br>	
		    		<a>14. Component Testing:</a><br>	
		    			<a>Този вид тестване се извършва най-вече от разработчиците след завършване на модулното тестване.
							Тестването на компоненти включва тестване на множество функционалности като един код и целта му е да идентифицира дали съществува някакъв дефект след свързването на тези множество функционалности една с друга.</a>
						<p></p>
		    			<br></br>
		    		<a>15. End-to-End Testing:</a><br>	
		    			<a>Подобно на системното тестване, тестването End-to-End (от край до край) включва тестване на пълна среда на приложение в ситуация, която имитира употреба в реалния свят, като взаимодействие с база данни, използване на мрежови комуникации или взаимодействие с друг хардуер, приложения или системи, ако подходящо..</a>
						<p></p>
		    			<br></br>	
		    		<a>16. Equivalence Partitioning:</a><br>	
		    			<a>Това е техника за тестване и вид тестване на черна кутия. По време на това разделяне на еквивалентност се избира набор от групи и се избират няколко стойности или числа за тестване.<br> 
		    			Разбираемо е, че всички стойности от тази група генерират еднакъв изход.
						Целта на това тестване е да се премахнат излишните тестови случаи в рамките на конкретна група, които генерират същия изход, но без никакъв дефект.
						Да предположим, че приложението приема стойности между -10 и +10, след което използвайки разделяне на еквивалентност, избраните стойности за тестване са нула, една положителна стойност и една отрицателна стойност. Така че разделянето на еквивалентност за това тестване е<br> 
					    -10 към -1, 0 и 1 до 10.</a>
						<p></p>
		    			<br></br>		
		    		<a>17. Example Testing:</a><br>	
		    			<a>This means real-time testing. Example Testing includes real-time scenarios, it also involves scenarios based on the experience of the testers.</a>
						<p></p>
		    			<br></br>
		    		<a>18. Exploratory Testing:</a><br>	
		    			<a>Проучвателното тестване е неформално тестване, извършвано от екипа за тестване. Целта на това тестване е да се проучи приложението и да се търсят дефекти, които съществуват в приложението.
						Понякога може да се случи, че по време на това тестване открит голям дефект може дори да причини повреда на системата. По време на проучвателното тестване е препоръчително да се следи какъв поток сте тествали и каква дейност сте извършили преди началото на конкретен поток.
						Техниките за проучвателно тестване се извършват без документация или тестови случаи.</a>
						<p></p>
		    			<br></br>	
		    		<a>19. Functional Testing:</a><br>	
		    			<a>Този тип тестване игнорира вътрешните части и се фокусира само върху изхода, за да провери дали отговаря на изискването или не.
						Това е тестване от типа на черна кутия, което е насочено към функционалните изисквания на дадено приложение.</a>
						<p></p>
		    			<br></br>
		    		<a>20. Graphical User Interface (GUI) Testing:</a><br>	
		    			<a>Целта на това GUI тестване е да потвърди GUI според бизнес изискването. Очакваният графичен интерфейс на приложението е споменат в документа за подробен проект и екраните за макет на GUI.
						GUI тестването включва размера на бутоните и полетата за въвеждане на екрана, подравняването на целия текст, таблици и съдържание в таблиците.
						Той също така потвърждава менюто на приложението, след като избира различни елементи от менюто и менюто, потвърждава, че страницата не се колебае и подравняването остава същото след задържане на мишката върху менюто или подменюто.</a>
						<p></p>
		    			<br></br>	
		    		<a>21. Gorilla Testing:</a><br>	
		    			<a>Gorilla Testing е тип тестване, извършвано от тестер, а понякога и от разработчик.
						При Gorilla Testing един модул или функционалността в модула се тества задълбочено и сериозно. Целта на това тестване е да се провери стабилността на приложението.</a>
						<p></p>
		    			<br></br>
		    		<a>22. Happy Path Testing:</a><br>	
		    			<a>Целта на Happy Path Testing е да се тества успешно приложение на положителен поток.
						Той не търси отрицателни условия или условия за грешка. Фокусът е само върху валидни и положителни входове,<br> чрез които приложението генерира очаквания резултат.</a>
						<p></p>
		    			<br></br>	
		    		<a>23. Incremental Integration Testing:</a><br>	
		    			<a>Тестването на постепенна интеграция е подход отдолу нагоре за тестване, т.е. непрекъснато тестване на приложение, когато се добавя нова функционалност.
						Функционалността и модулите на приложението<br>
					    трябва да са достатъчно независими, за да тестват отделно. Това се прави от програмисти или от тестери.</a>
						<p></p>
		    			<br></br>	
		    		<a>24. Install/Uninstall Testing:</a><br>	
		    			<a>Тестването за инсталиране и деинсталиране се извършва при пълни, частични или надстроени процеси на инсталиране/деинсталиране на различни операционни системи в различни хардуерни или софтуерни среди.</a>
						<p></p>
		    			<br></br>	
		    		<a>25. Integration Testing:</a><br>	
		    			<a>Тестването на всички интегрирани модули за проверка на комбинираната функционалност след интегрирането се нарича тестване на интеграция.
						Модулите обикновено са кодови модули, отделни приложения, клиентски и сървърни приложения в мрежа и т.н. Този тип тестване е особено подходящ за клиент/сървър и разпределени системи.</a>
						<p></p>
		    			<br></br>	
		    		<a>26. Load Testing:</a><br>	
		    			<a>Това е вид нефункционално тестване, а целта на тестването за натоварване е да провери колко натоварване или максимално натоварване може да поеме системата без никакво влошаване на производителността.
						Тестването на натоварване помага да се намери максималния капацитет на системата при специфично натоварване и всички проблеми, които причиняват влошаване на производителността на софтуера.<br> 
					    Тестването на натоварване се извършва с помощта на инструменти като JMeter, LoadRunner, WebLoad, Silk performer и др.</a>
						<p></p>
		    			<br></br>				
		    		<a>27. Monkey Testing:</a><br>	
		    			<a>Тестването на "маймуна"" се извършва от тестер, като се предполага, че ако "маймуна" използва приложението, тогава как произволно въвеждане на стойности ще бъдат въведени от маймуната без никакво познаване или разбиране на приложението.
						Целта на Monkey Testing е да провери дали дадено приложение или система се срива чрез предоставяне на произволни входни стойности/данни. Monkey Testing се извършва на случаен принцип и не се скриптират тестови случаи, не е необходимо тестера да е наясно с пълната функционалност на системата.</a>
						<p></p>
		    			<br></br>
		    		<a>28. Mutation Testing:</a><br>	
		    			<a>Mutation Testing е вид тестване от "white box", при което изходният код на една от програмите се променя и се проверява дали съществуващите тестови случаи могат да идентифицират тези дефекти в системата.
						Промяната в изходния код на програмата е много минимална, така че не засяга цялото приложение, а само конкретната област, която оказва влияние, и свързаните тестови случаи трябва да могат да идентифицират тези грешки в системата.</a>
						<p></p>
		    			<br></br>
		    		<a>29. Negative Testing:</a><br>	
		    			<a>Тестерите имат нагласа за „отношение към счупване“ и използвайки отрицателно тестване, те проверяват, <br><ако системата или приложението се счупи.
						Техниката за отрицателно тестване се извършва с помощта на неверни данни, невалидни данни.<br> 
						Той проверява дали системата вдига грешка при невалидно въвеждане и показва поведение според очакванията.</a>
						<p></p>
		    			<br></br>		
 					<a>30. Non-Functional Testing:</a><br>	
		    			<a>Това е вид тестване, за което всяка организация има отделен екип, който обикновено се нарича екип за нефункционален тест (NFT) или екип за ефективност.
						Нефункционалното тестване включва тестване на нефункционални изисквания като тестване на натоварване, тестване на стрес, сигурност, обем, тест за възстановяване и т.н. Целта на тестването на NFT е да се гарантира дали времето за реакция на софтуера<br>
						или приложението е достатъчно бързо според бизнес изискване.
						Зареждането на която и да е страница или система не трябва да отнема много време и трябва да се поддържа по време на пиково натоварване.</a>
						<p></p>
		    			<br></br>
		    		<a>31. Performance Testing:</a><br>	
		    			<a>Този термин често се използва взаимозаменяемо с тестове за „стрес“ и „натоварване“.<br>
						Тестването на производителността се извършва, за да се провери дали системата отговаря на изискванията<br>
						 за производителност. За извършване на това тестване се използват различни инструменти за производителност и натоварване.</a>
						<p></p>
		    			<br></br>	
		    		<a>32. Recovery Testing:</a><br>	
		    			<a>Това е вид тестване, което потвърждава колко добре приложението или системата се възстановяват<br>
		    		    от сривове или бедствия.
						Тестването за възстановяване определя дали системата е в състояние да продължи работата си след бедствие. Да приемем, че приложението получава данни през мрежов кабел и изведнъж<br>
					    този мрежов кабел е бил изключен.
						След известно време включете мрежовия кабел; тогава системата трябва да започне да получава данни от мястото, където е загубила връзката поради изключване на мрежовия кабел.</a>
						<p></p>
		    			<br></br>		
		    		<a>33. Regression Testing:</a><br>	
		    			<a>Тип софтуерно тестване, което се използва за проверка на всяка модификация или актуализация в софтуер, без да се засяга цялостната работна функционалност на споменатия софтуер. Регресионното тестване се извършва, когато има промяна на кода в софтуерно приложение.</a>
						<p></p>
		    			<br></br>	
		    		<a>34. Risk-Based Testing (RBT):</a><br>	
		    			<a>За тестване, базирано на риска, функционалностите или изискванията се тестват въз основа на техния приоритет. Тестването, базирано на риска, включва тестване на изключително критична функционалност, която има най-голямо въздействие върху бизнеса и при която вероятността от неуспех е много висока.
						Приоритетните решения се основават на нуждите на бизнеса, така че след като приоритетът е зададен за всички функционалности, първо се изпълняват функционалност с висок приоритет или тестови случаи, последвани от функционалности със среден и след това нисък приоритет.
						Функционалността с нисък приоритет може да бъде тествана или не тествана въз основа на наличното време. Тестването, базирано на риска, се извършва, ако няма достатъчно време за тестване на целия софтуер и софтуерът трябва да бъде внедрен навреме без никакво забавяне.
						Този подход е последван само от обсъждане и одобрение от клиента<br>
					    и висшето ръководство на организацията.</a>
						<p></p>
		    			<br></br>	
		    		<a>35. Sanity Testing:</a><br>	
		    			<a>Тестването за здравина се прави, за да се определи дали новата версия на софтуера се представя достатъчно добре, за да бъде приета за тестване или не.
						Ако дадено приложение се срива при първоначална употреба, то тогава системата не е достатъчно стабилна за по-нататъшно тестване.</a>
						<p></p>
		    			<br></br>		
		    		<a>36. Security Testing:</a><br>	
		    			<a>Това е вид тестване, извършвано от специален екип от тестери. В системата може да се проникне чрез всеки хакерски метод.
						Тестването на сигурността се извършва, за да се провери доколко софтуерът, приложението или уебсайтът са защитени от вътрешни и външни заплахи. Този вид тестване се занимава с това колко е защитен софтуерът от злонамерени програми, вируси и колко сигурни и силни са процесите на оторизация и удостоверяване.
						Той също така проверява как се държи софтуерът при всякакви хакерски атаки и злонамерени програми и как се осигурява сигурността на данните след такава хакерска атака.</a>
						<p></p>
		    			<br></br>	
		    		<a>37. Smoke Testing:</a><br>	
		    			<a>Всеки път, когато DEV предоставя нова версия, екипът за тестване на софтуер валидира компилацията и гарантира, че няма голям проблем.
						Ако тестерите установят, че основната критична функционалност е разбита в самия начален етап, то тогавa екипа може да отхвърли версията<br> и съответно да информира екипа за разработка. Тестването "smoke" се извършва до детайлно ниво на всяка функционалност.</a><br>
					    <p></p>
		    			<br></br>	
		    		<a>38. Static Testing:</a><br>	
		    			<a>Статичното тестване е вид тестване, което се изпълнява без никакъв код. Изпълнението ще се извърши<br> върху документацията по време на фазата на тестване.
						Статичното тестване е приложимо и за тестови сценарии върху проектни документи. Трябва да се извърши статично тестване, тъй като дефектите, идентифицирани по време на този тип тестване, са рентабилни от гледна точка на проекта.</a><br>
					    <p></p>
		    			<br></br>
		    		<a>39. Stress Testing:</a><br>	
		    			<a>Това тестване се прави, когато дадена система е натоварена извън своите спецификации, за да се провери<br> как и кога се проваля.
						Това се извършва при голямо натоварване като поставяне на голям брой извън капацитета за съхранение, сложни заявки към база данни, непрекъснато въвеждане в системата или натоварване на базата данни.</a><br>
					    <p></p>
		    			<br></br>	
		    		<a>40. System Testing:</a><br>	
		    			<a>При тази техниката за тестване на цялата система се тества според изискванията.<br>
		    			Това е тестване от типа на "black box", което се основава на общите спецификации на изискванията<br>
		    		    и обхваща всички комбинирани части на системата.</a><br>
					    <p></p>
		    			<br></br>	
		    		<a>41. Unit Testing:</a><br>	
		    			<a>Тестването на отделен софтуерен компонент или модул се нарича Unit Testing.
						Обикновено се прави от програмист, а не от тестер, тъй като изисква подробно познаване на вътрешния програмен дизайн и код.</a><br>
					    <p></p>
		    			<br></br>
		    		<a>42. Usability Testing:</a><br>	
		    			<a>Това е тип тестване на приложение, който да определи дали нов потребител може лесно да разбере приложението или не. При това тестване се проверява системната навигация.</a><br>
					    <p></p>
		    			<br></br>
		    		<a>43. Vulnerability Testing:</a><br>	
		    			<a>Тестването, което включва идентифициране на слабости в софтуера, хардуера и мрежата, е известно като тестване на уязвимости. При злонамерени програми хакерът може да поеме контрола над системата, ако тя е уязвима към подобен вид атаки, вируси и червеи.
						Трябва да проверим дали тези системи преминават тест за уязвимост преди производството. Той може да идентифицира критични дефекти и пропуски в сигурността.</a><br>
					    <p></p>
		    			<br></br>	
		    		<a>44. Volume Testing:</a><br>	
		    			<a>Обемното тестване е вид нефункционално тестване, извършвано от екипа за тестване на производителността.
						Софтуерът или приложението претърпява огромно количество данни и Volume Testing проверява поведението на системата и времето за реакция на приложението, когато системата се натъкне на такъв голям обем данни.
						Този голям обем данни може да повлияе на производителността на системата и скоростта на времето за обработка.</a><br>
					    <p></p>
		    			<br></br>
		    		<a>45. White Box Testing:</a><br>	
		    			<a>Тестването "бялата кутия" се основава на познанията за вътрешната логика на кода на приложението.
						Известно е още като тестване на "стъклена кутия". Вътрешният софтуер и работата с код трябва да са известни за извършване на този тип тестване. </a><br>
					    <p></p>
		    			<br></br>		
			</div>

			<div class="crud-img"><a><img src ="img/testingTypes.png"</a></div>
			
		</body>
	</html>






















































